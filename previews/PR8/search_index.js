var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartitionedVectors]","category":"page"},{"location":"reference/#PartitionedVectors.AbstractPartitionedVector","page":"Reference","title":"PartitionedVectors.AbstractPartitionedVector","text":"AbstractPartitionedVector{T} <: DenseVector{T}\n\nAbstract type for PartitionedVector<:AbstractPartitionedVector{T}. Krylov.jl requires PartitionedVector<:DenseVector{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedVectors.PartitionedVector","page":"Reference","title":"PartitionedVectors.PartitionedVector","text":"PartitionedVector{T} <: AbstractPartitionedVector{T}\n\nWrap PartitionedStructures.Elemental_pv to behave almost as an AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.getindex-Tuple{PartitionedVector, Vararg{Any}}","page":"Reference","title":"Base.getindex","text":"element_vector = getindex(pv::PartitionedVector, i::Int)\n\nReturn the i-th element of pv, e.g. the i-th element vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.setindex!-Tuple{PartitionedVector, PartitionedStructures.ModElemental_ev.Elemental_elt_vec, Int64}","page":"Reference","title":"Base.setindex!","text":"setindex!(pv::PartitionedVector, val::Elemental_elt_vec, index::Int)\nsetindex!(pv::PartitionedVector{T}, val::T, index::Int) where T<:Number\nsetindex!(pv::PartitionedVector{T}, val::Vector{T}, index::Int) where T<:Number\n\nSet pv[index] (e.g. the index-th element vector) to val.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors.LinearOperator_for_Vector-Union{Tuple{PartitionedStructures.M_part_mat.Part_mat{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedVectors.LinearOperator_for_Vector","text":"lo = LinearOperator_for_Vector(epm::Part_mat{T})\n\nReturn the linear-operator lo which use a partitioned-matrix and Vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors._filter-Tuple{Int64, Tuple{}}","page":"Reference","title":"PartitionedVectors._filter","text":"_filter(i::Int, arg::Tuple{})\nelement_vector = _filter(i::Int, arg::PartitionedVector)\n_filter(i::Int, arg::Any)\n_filter(i::Int, args::Tuple)\n\nPass through a Tuple to select the i-th element if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors.build!-Tuple{PartitionedVector}","page":"Reference","title":"PartitionedVectors.build!","text":"build!(pv::PartitionedVector)\n\nSet in place of pv.epv.v the Vector that pv represents. If pv.simulate=false, it aggregates contributions from elemental vectors. If pv.simulate=true, common variables among element vectors value the same. For each index 1 ≤ i ≤ n, , build! will take the first element containing i and sets pv.epv.v[i] to its value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors.find_pv-Tuple{Base.Broadcast.Broadcasted}","page":"Reference","title":"PartitionedVectors.find_pv","text":"pv = find_pv(bc::Base.Broadcast.Broadcasted)\npv = find_pv(x::PartitionedVector)\npv = find_pv(x::PartitionedVector, a::Any)\npv = find_pv(x::Any, a::Any)\n\nPass through a Broadcasted tape to retrieve a PartitionedVector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors.partitionedMulOp!-Tuple{PartitionedStructures.M_part_mat.Part_mat, PartitionedVector, PartitionedVector, PartitionedVector, Any, Any}","page":"Reference","title":"PartitionedVectors.partitionedMulOp!","text":"partitionedMulOp!(epm::PS.Part_mat, Hv::PartitionedVector, pv_res::PartitionedVector, pv::PartitionedVector, α, β)\n\nPartitioned matrix-vector product for PartitionedVectors: Hv, res and v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors.partitionedMulOpVec!-Union{Tuple{T}, Tuple{PartitionedStructures.M_part_mat.Part_mat{T}, Vector{T}, Vector{T}, Vector{T}, Any, Any}} where T","page":"Reference","title":"PartitionedVectors.partitionedMulOpVec!","text":"partitionedMulOpVec!(epm::PS.Part_mat{T}, Hv::Vector{T}, res::Vector{T}, v::Vector{T}, α, β;\n\nPartitioned matrix-vector product for Vectors: Hv, res and v. Made to test LinearOperators.LinearOperator(epm::Part_mat{T}) (which relies on PartitionedVectors).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedVectors.set!-Union{Tuple{T}, Tuple{PartitionedVector{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedVectors.set!","text":"set!(pv::PartitionedVector{T}, v::Vector{T})\n\nSet inplace pv such that each element values Uᵢv.\n\n\n\n\n\n","category":"method"},{"location":"#PartitionedVectors.jl","page":"Home","title":"PartitionedVectors.jl","text":"","category":"section"},{"location":"tutorial/#PartitionedVectors.jl-Tutorial","page":"Tutorial","title":"PartitionedVectors.jl Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PartitionedVectors is a wrapper around the Elemental_pv, a partitioned data structure defined in PartitionedStructures.jl, to make it behave as an AbstractVector. It implements PartitionedVector <: DenseVector <: AbstractVector, which aims to define PartiallySeparableNLPModels, and then to consequently:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"replace Vector in JSOSolvers.jl; \nreplace Vector in KrylovSolvers.jl;\nmake LinearOperators relying only on PartitionedVectors viable;\nfit consequently the NLPModels interface (ex: NLPModels.obj(nlp::PartiallySeparableNLPModel, x::PartitionedVector) see PartiallySeparableNLPModels.jl for more details).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Partitioned vectors usages are related to partially separable problems:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" f(x) = sum_i=1^N f_i (U_i x)   f_i  R^n_i to R  U_i in R^n_i times n n_i ll n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"whose inherit partitioned derivatives:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" nabla f(x) = sum_i=1^N U_i^top nabla f_i (U_i x) quad nabla^2 f(x) = sum_i=1^N U_i^top nabla^2 f_i (U_i x) U_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where the set of U_i gathers all the information related to the partitioned structure. We consider U_i a linear application selecting the variable that parametrize the i-th element function f_i, each U_i is defined from a vector of integers. The partially separable function ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = f_1(x_1x_2x_3x_4) + f_2(x_3x_4x_5x_6) + f_3(x_5x_6x_7) + f_4(x_5x_6x_8)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get the following U_i:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U1 = [1, 2, 3, 4]\nU2 = [3, 4, 5, 6]\nU3 = [5, 6, 7]\nU4 = [5, 6, 8]\nUis = [U1, U2, U3, U4]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, before defining a PartitionedVector, you must understand the two usages of PartitionedVectors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"usage 1: store each element contribution hatv_i independently and aggregate them to form v = sum_i=1^N U_i^top hatv_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In optimization methods, you use it to store nabla f_i (U_i x), y_i = nabla f_i (U_i x_k+1) - nabla f_i (U_i x_k) or the result of a partitioned hessian-vector product which is a partitioned vector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" nabla^2 f(x_k) s approx B_k s = (sum_i=1^N U_i^top B_ki U_i ) s = sum_i=1^N U_i^top (B_ki U_i s) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"usage 2: represent simultaneously a vector x in mathbbR^n and the application of every U_i on to x: U_i x forall i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By construction, the elements parametrized the same variables (for exemple U1 and U3 are parametrized by the third variable) share the same values. In optimization methods, it allows to store the current point x_k or step s_k, which always comes in handy to evaluate f_i(U_i x) nabla f_i(U_i x) or B_ki U_i s.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any methods exploiting partially separable concepts will have to manipulate both usages at the same time, in particular the solvers from JSOSolvers.jl and Krylov.jl. By default, you can define a PartitionedVector just from Uis as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartitionedVectors\npv = PartitionedVector(Uis)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which will be of usage 1. If you want a vector for usage 2 you have to set simulate_vector optional argument to true","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pv_vec = PartitionedVector(Uis; simulate_vector=true)\n# set each element as a view of rand(length(pv_vec))\nset!(pv_vec, rand(length(pv_vec))) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PartitionedVectors.jl specify several methods from various modules. Warning: you have to be careful when you mix both usages in a single operation, by default, the result will take usage 1. Base.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"elementary operations +, -, *, == for PartitionedVectors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pv + pv == 2 * pv\npv - pv == 0 * pv","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, it supports the broadcast for the same operations (unfortunately not in place for now).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pv .+ pv == 2 .* pv\npv .- pv == 0 .* pv","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"supports methods related to AbstractArrays such as: \nget_index, set_index! refers to the i-th element vector of pv\npv[1]\npv2 = pv - 0.5 * pv\npv[1] = pv2[1]\npv[1] == pv[2]\nfirstindex, lastindex, size, length:\nfirstindex(pv) == 1\nlastindex(pv) == 4  \nsize(pv) == (4,)\nlength(pv) == 8\nnote that size and length differ, length refers to the biggest index (e.g. n) while size refers to the number of elements N.\ncopy, similar;\npvcopy = copy(pv)\npvsimilar = similar(pv)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"LinearAlgebra:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearAlgebra\ndot(pv,pv) ≈ norm(pv)^2","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition, PartitionedVectors.jl defines a:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"LinearOperator from a PartitionedMatrix (see PartitionedStructures.jl) relying on PartitionedVectors","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartitionedStructures\nepm = PartitionedStructures.identity_epm(Uis)\nlo = LinearOperators.LinearOperator(epm)\nlo * pv","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note: Matrix(lo) will produce an error, since the default implementation assumes a complete Vector-like behaviour.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dedicated CGSolver from Krylov.jl to solve a partitioned linear system (from a partitioned LinearOperator).","category":"page"}]
}
